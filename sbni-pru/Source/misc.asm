	.cdecls C,NOLIST
	%{
		#include "main.h"
		#include "config.h"
	%}

	.ref ||rx_pointer||
	.ref ||rx_timeout||
	.ref ||rx_count||
	.ref ||rx_delay||
	.ref ||__receive_byte||

;*--------------------------------------------------------------------------------------*
;* Специализированные регистры:
;* R2 - регистр с адресом стека
;* R3 - регистр для хранения адресов программы
;* R14 - регистр для передачи аргументов между функциями
;* R30 - регистр для управления выводами процессора
;* R31 - регистр состояния (в т.ч. вводов процессора)
;*--------------------------------------------------------------------------------------*

	.sect ".text:__event_wait"
	.clink
	.global ||__event_wait||

;*----------------------------------------------------------------------------------------------------*
;* unsigned char __event_wait(void)
;*
;* @ Brief:  Функция представляет собой цикл, в котором считываются все внешние
;*           события.
;* @ Param:  Нет
;* @ Return: Код события
;*----------------------------------------------------------------------------------------------------*

||__event_wait||
	SUB		r2, r2, 2							; выделить память в стеке
	SBBO	&r3.w2, r2, 0, 2					; сохранить адрес возврата
$EVL_0:
	ZERO	&r5, 8								; обнулить регистры r5 и r6
	ZERO	&r14, 4								; обнулить регистр r14
	AND		r5, r31, SBNI_RX					; зафиксировать изначальный уровень на входе
$EVL_1:
	AND		r6, r31, SBNI_RX
	QBNE	$EVL_2, r5, r6						; если он отличается от изначального, перейти к $EVL_2
	QBBC	$EVL_1, r31, HOST_INTERRUPT			; повторить цикл, если нет прерывания от хоста
	JMP		$EVL_3								; иначе перейти к $EVL_3
$EVL_2:
	JAL		r3.w2, ||__check_preamble||			; вызвать __check_preamble
	QBNE	$EVL_0, r14.b0, 0					; если функция вернула не 0, перейти к $EVL_0
	JAL		r3.w2, ||__receive_byte||			; иначе вызвать __receive_byte
	LDI		r0, ||rx_pointer||					; загрузить адрес rx_pointer
	SBBO	&r10, r0, 0, 4						; сохранить содержимое r10 в rx_pointer
	LDI		r0, ||rx_count||					; загрузить адрес rx_count
	SBBO	&r11, r0, 0, 4						; сохранить содержимое r11 в rx_count
	LDI		r14.b0, EXTERNAL_EVENT_RX_PENDING	; байт, возвращаемый функцией
	JMP		$EVL_4								; перейти к $EVL_4
$EVL_3:
	LDI 	r14.b0, EXTERNAL_EVENT_HOST_INTR	; байт, возвращаемый функцией
$EVL_4:
	LBBO	&r3.w2, r2, 0, 2					; загрузить адрес возврата из стека
	ADD		r2, r2, 2							; освободить память в стеке
	JMP		r3.w2								; перейти по адресу возврата
;*----------------------------------------------------------------------------------------------------*

	.sect ".text:__detect_valid_seq"
	.clink
	.global ||__detect_valid_seq||

;*----------------------------------------------------------------------------------------------------*
;* unsigned char __event_wait(void)
;*
;* @ Brief:  Проверить преамбулу входящего потока данных (должно быть 8 нулей подряд)
;* @ Param:  Нет
;* @ Return: Разница между ожидаемым и фактическим кол-вом нулей
;*----------------------------------------------------------------------------------------------------*

||__check_preamble||
	SUB		r2, r2, 2					; выделить память в стеке
	SBBO	&r3.w2, r2, 0, 2			; сохранить адрес возврата
	ZERO	&r1, 4						; обнулить r1
	QBLT	$DVL_0, r6, r5				; если пришёл положительный фронт, перейти к $DVL_0
	ADD		r1.b0, r1.b0, 1				; иначе увеличить счётчик нулей
	ADD		r1.b1, r1.b1, 1				; и счётчик принятых бит
$DVL_0:
	AND		r5, r31, SBNI_RX			; зафиксировать уровень на входе
	LDI		r0, ||rx_delay||			; загрузить адрес rx_delay
	LBBO	&r14, r0, 0, 4				; загрузить значение rx_delay
	JAL		r3.w2, ||__delay_loop||		; вызвать __delay_loop
	AND		r6, r31, SBNI_RX			; зафиксировать уровень на входе
	LDI		r0, ||rx_timeout||			; загрузить адрес rx_timeout
	LBBO	&r14, r0, 0, 4				; загрузить значение rx_timeout в счётчик ожидания
	ADD		r1.b1, r1.b1, 1				; увеличить счётчик принятых бит
	QBNE	$DVL_2, r5, r6				; если изменение уровня было, перейти к $DVL_2
	ADD		r1.b0, r1.b0, 1				; иначе увеличить счётчик нулей
$DVL_2:
	QBEQ	$DVL_3, r14, 0				; если счётчик ожидания равен 0, перейти к $DVL_3
	AND		r5, r31, SBNI_RX			; иначе зафиксировать уровень на входе
	SUB		r14, r14, 1					; уменьшить счётчик ожидания на 1
	QBEQ	$DVL_2, r5, r6				; если уровень не изменился, вернуться к $DVL_2
	QBNE	$DVL_0, r1.b1, 8			; иначе если счётчик принятых бит != 0 перейти к $DVL_0
$DVL_3:
	ZERO	&r14, 4						; иначе обнулить r14
	SUB		r1.b0, r1.b0, r1.b1			; отнять кол-во принятых нулей от кол-ва принятых бит
	MOV		r14.b0, r1.b0				; поместить результат в r14
	LBBO	&r3.w2, r2, 0, 2			; загрузить адрес возврата
	ADD		r2, r2, 2					; освободить память в стеке
	JMP		r3.w2						; перейти к адресу возврата
;*----------------------------------------------------------------------------------------------------*


	.sect ".text:__delay_loop"
	.clink
	.global ||__delay_loop||

;*----------------------------------------------------------------------------------------------------*
;* void __delay_loop(unsigned int delay)
;*
;* @ Brief:  Функция задержки (delay/2 + 2 тактов)
;* @ Param:  Кол-во циклов задержки (каждый цикл = 2 такта процессора
;*			 + 2 такта на вход и выход из функции)
;* @ Return: Нет
;*----------------------------------------------------------------------------------------------------*

||__delay_loop||:
	QBEQ	$DLL_2, r14, 0				; если r14 = 0 перейти к $DLL_2
$DLL_1:
	SUB  	r14, r14, 1		    		; уменьшить счётчик на 1
	QBNE 	$DLL_1, r14, 0				; если счётчик != 0 вернуться к $DLL_1
$DLL_2:
	JMP		r3.w2						; перейти к адресу возврата
;*----------------------------------------------------------------------------------------------------*
